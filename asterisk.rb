require 'formula'

class Asterisk < Formula
  homepage 'http://www.asterisk.org'
  url 'http://downloads.asterisk.org/pub/telephony/asterisk/releases/asterisk-13.0.1.tar.gz'
  sha1 'a3b6da0d6f474644b5643944d7ac16afc581168a'

  # Asterisk depends on specific GCC features
  fails_with :clang
  fails_with :llvm

  depends_on 'pkg-config' => :build

  depends_on 'gmime'
  depends_on 'iksemel'
  depends_on 'jansson'
  depends_on 'ncurses'
  depends_on 'openssl'
  depends_on 'pjsip-asterisk'
  depends_on 'speex'
  depends_on 'sqlite'
  depends_on 'srtp'
  depends_on 'unixodbc'

  patch :p0, :DATA

  def install
    # To help debug broken builds
    if ARGV.verbose?
      # disable parallel builds
      ENV.j1
    end

    openssl = Formula['openssl']
    sqlite = Formula['sqlite']
    unixodbc = Formula['unixodbc']
    pjsip = Formula['pjsip-asterisk']

    # Some Asterisk code doesn't follow strict aliasing rules
    ENV.append "CFLAGS", "-fno-strict-aliasing"

    # Use brew's pkg-config
    ENV["PKG_CONFIG"] = "#{HOMEBREW_PREFIX}/bin/pkg-config"

    system "./configure", "--prefix=#{prefix}",
                          "--with-pjsip=#{pjsip.opt_prefix}",
                          "--with-sqlite3=#{sqlite.opt_prefix}",
                          "--with-ssl=#{openssl.opt_prefix}",
                          "--with-unixodbc=#{unixodbc.opt_prefix}",
                          "--without-gmime",
                          "--without-gtk2",
                          "--without-iodbc",
                          "--without-netsnmp"

    system "make", "menuselect/cmenuselect",
                   "menuselect/nmenuselect",
                   "menuselect/gmenuselect",
                   "menuselect/menuselect",
                   "menuselect-tree",
                   "menuselect.makeopts"

    # Inline function cause errors with Homebrew's gcc-4.8
    system "menuselect/menuselect",
           "--enable", "DISABLE_INLINE", "menuselect.makeopts"
    # Native compilation doesn't work with Homebrew's gcc-4.8
    system "menuselect/menuselect",
           "--disable", "BUILD_NATIVE", "menuselect.makeopts"

    system "make", "all", "NOISY_BUILD=yes"
    system "make", "install"
  end
end
__END__
# Patch to get OS X builds back into shape
Index: channels/sip/include/route.h
===================================================================
--- channels/sip/include/route.h	(revision 428631)
+++ channels/sip/include/route.h	(working copy)
@@ -98,7 +98,7 @@
  * \retval NULL on failure
  */
 struct ast_str *sip_route_list(const struct sip_route *route, int formatcli, int skip)
-		__attribute_malloc__ __attribute_warn_unused_result__;
+	__attribute__((__malloc__)) __attribute__((__warn_unused_result__));
 
 /*!
  * \brief Check if the route is strict
Index: configure
===================================================================
--- configure	(revision 428631)
+++ configure	(working copy)
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.ac Revision: 421230 .
+# From configure.ac Revision: 425965 .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.69 for asterisk trunk.
 #
@@ -15267,7 +15267,7 @@
 done
 
 
-for ac_func in asprintf atexit closefrom dup2 eaccess endpwent euidaccess ffsll ftruncate getcwd gethostbyname gethostname getloadavg gettimeofday glob htonll ioperm inet_ntoa isascii memchr memmove memset mkdir mkdtemp munmap ntohll newlocale ppoll putenv re_comp regcomp select setenv socket strcasecmp strcasestr strchr strcspn strdup strerror strlcat strlcpy strncasecmp strndup strnlen strrchr strsep strspn strstr strtod strtol strtold strtoq unsetenv utime vasprintf getpeereid sysctl swapctl
+for ac_func in asprintf atexit closefrom dup2 eaccess endpwent euidaccess ffsll ftruncate getcwd gethostbyname gethostname getloadavg gettimeofday glob ioperm inet_ntoa isascii memchr memmove memset mkdir mkdtemp munmap newlocale ppoll putenv re_comp regcomp select setenv socket strcasecmp strcasestr strchr strcspn strdup strerror strlcat strlcpy strncasecmp strndup strnlen strrchr strsep strspn strstr strtod strtol strtold strtoq unsetenv utime vasprintf getpeereid sysctl swapctl
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
@@ -15280,6 +15280,60 @@
 done
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for htonll" >&5
+$as_echo_n "checking for htonll... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <arpa/inet.h>
+int
+main ()
+{
+return htonll(0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HAVE_HTONLL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ntohll" >&5
+$as_echo_n "checking for ntohll... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <arpa/inet.h>
+int
+main ()
+{
+return ntohll(0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HAVE_NTOHLL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+
 # NOTE: we use AC_CHECK_LIB to get -lm into the arguments for later checks,
 # so that AC_CHECK_FUNCS can detect functions in that library.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for sqrt in -lm" >&5
Index: configure.ac
===================================================================
--- configure.ac	(revision 428631)
+++ configure.ac	(working copy)
@@ -657,8 +657,26 @@
 AC_FUNC_STRTOD
 AC_FUNC_UTIME_NULL
 AC_FUNC_VPRINTF
-AC_CHECK_FUNCS([asprintf atexit closefrom dup2 eaccess endpwent euidaccess ffsll ftruncate getcwd gethostbyname gethostname getloadavg gettimeofday glob htonll ioperm inet_ntoa isascii memchr memmove memset mkdir mkdtemp munmap ntohll newlocale ppoll putenv re_comp regcomp select setenv socket strcasecmp strcasestr strchr strcspn strdup strerror strlcat strlcpy strncasecmp strndup strnlen strrchr strsep strspn strstr strtod strtol strtold strtoq unsetenv utime vasprintf getpeereid sysctl swapctl])
+AC_CHECK_FUNCS([asprintf atexit closefrom dup2 eaccess endpwent euidaccess ffsll ftruncate getcwd gethostbyname gethostname getloadavg gettimeofday glob ioperm inet_ntoa isascii memchr memmove memset mkdir mkdtemp munmap newlocale ppoll putenv re_comp regcomp select setenv socket strcasecmp strcasestr strchr strcspn strdup strerror strlcat strlcpy strncasecmp strndup strnlen strrchr strsep strspn strstr strtod strtol strtold strtoq unsetenv utime vasprintf getpeereid sysctl swapctl])
 
+AC_MSG_CHECKING(for htonll)
+AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM([#include <arpa/inet.h>],
+		[return htonll(0);])],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(HAVE_HTONLL, 1, [Define to 1 if arpa/inet.h includes a htonll definition.]),
+	AC_MSG_RESULT(no)
+)
+
+AC_MSG_CHECKING(for ntohll)
+AC_LINK_IFELSE(
+	[AC_LANG_PROGRAM([#include <arpa/inet.h>],
+		[return ntohll(0);])],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(HAVE_NTOHLL, 1, [Define to 1 if arpa/inet.h includes a ntohll definition.]),
+	AC_MSG_RESULT(no)
+)
+
 # NOTE: we use AC_CHECK_LIB to get -lm into the arguments for later checks,
 # so that AC_CHECK_FUNCS can detect functions in that library.
 AC_CHECK_LIB([m], [sqrt])
Index: funcs/func_presencestate.c
===================================================================
--- funcs/func_presencestate.c	(revision 428631)
+++ funcs/func_presencestate.c	(working copy)
@@ -41,7 +41,7 @@
 #include "asterisk/app.h"
 #ifdef TEST_FRAMEWORK
 #include "asterisk/test.h"
-#include <semaphore.h>
+#include "asterisk/sem.h"
 #endif
 
 /*** DOCUMENTATION
@@ -664,7 +664,7 @@
 struct test_cb_data {
 	struct ast_presence_state_message *presence_state;
 	/* That's right. I'm using a semaphore */
-	sem_t sem;
+	struct ast_sem sem;
 };
 
 static struct test_cb_data *test_cb_data_alloc(void)
@@ -675,7 +675,7 @@
 		return NULL;
 	}
 
-	if (sem_init(&cb_data->sem, 0, 0)) {
+	if (ast_sem_init(&cb_data->sem, 0, 0)) {
 		ast_free(cb_data);
 		return NULL;
 	}
@@ -686,7 +686,7 @@
 static void test_cb_data_destroy(struct test_cb_data *cb_data)
 {
 	ao2_cleanup(cb_data->presence_state);
-	sem_destroy(&cb_data->sem);
+	ast_sem_destroy(&cb_data->sem);
 	ast_free(cb_data);
 }
 
@@ -699,7 +699,7 @@
 	cb_data->presence_state = stasis_message_data(msg);
 	ao2_ref(cb_data->presence_state, +1);
 
-	sem_post(&cb_data->sem);
+	ast_sem_post(&cb_data->sem);
 }
 
 static enum ast_test_result_state presence_change_common(struct ast_test *test,
@@ -727,7 +727,7 @@
 		return AST_TEST_FAIL;
 	}
 
-	sem_wait(&cb_data->sem);
+	ast_sem_wait(&cb_data->sem);
 
 	ast_copy_string(out_state, ast_presence_state2str(cb_data->presence_state->state), out_state_size);
 	ast_copy_string(out_subtype, cb_data->presence_state->subtype, out_subtype_size);
Index: include/asterisk/autoconfig.h.in
===================================================================
--- include/asterisk/autoconfig.h.in	(revision 428631)
+++ include/asterisk/autoconfig.h.in	(working copy)
@@ -324,7 +324,7 @@
 /* Define to 1 if you have the Hoard Memory Allocator library. */
 #undef HAVE_HOARD
 
-/* Define to 1 if you have the `htonll' function. */
+/* Define to 1 if arpa/inet.h includes a htonll definition. */
 #undef HAVE_HTONLL
 
 /* Define to 1 if you have the iCal library. */
@@ -524,7 +524,7 @@
 /* Define to 1 if you have the newt library. */
 #undef HAVE_NEWT
 
-/* Define to 1 if you have the `ntohll' function. */
+/* Define to 1 if arpa/inet.h includes a ntohll definition. */
 #undef HAVE_NTOHLL
 
 /* Define to 1 if your C library can safely print NULL to string formats. */
Index: include/asterisk/sem.h
===================================================================
--- include/asterisk/sem.h	(revision 428631)
+++ include/asterisk/sem.h	(working copy)
@@ -59,6 +59,11 @@
 	return sem_wait(&sem->real_sem);
 }
 
+static force_inline int ast_sem_timedwait(struct ast_sem *sem, const struct timespec *abs_timeout)
+{
+	return sem_timedwait(&sem->real_sem, abs_timeout);
+}
+
 static force_inline int ast_sem_getvalue(struct ast_sem *sem, int *sval)
 {
 	return sem_getvalue(&sem->real_sem, sval);
@@ -137,6 +142,20 @@
 int ast_sem_wait(struct ast_sem *sem);
 
 /*!
+ * \brief Decrements the semaphore, waiting until abs_timeout.
+ *
+ * If the semaphore's current value is zero, this function blocks until another
+ * thread posts (ast_sem_post()) to the semaphore (or is interrupted by a signal
+ * handler, which sets errno to EINTR).
+ *
+ * \param sem Semaphore to decrement.
+ *
+ * \return 0 on success.
+ * \return -1 on error, errno set to indicate error.
+ */
+int ast_sem_timedwait(struct ast_sem *sem, const struct timespec *abs_timeout);
+
+/*!
  * \brief Gets the current value of the semaphore.
  *
  * If threads are blocked on this semaphore, POSIX allows the return value to be
Index: main/app.c
===================================================================
--- main/app.c	(revision 428631)
+++ main/app.c	(working copy)
@@ -2901,7 +2901,9 @@
 		ast_replace_sigchld();
 	}
 
-	sigfillset(&signal_set);
+	/* GCC 4.9 gives a bogus "right-hand operand of comma expression has
+	 * no effect" warning */
+	(void) sigfillset(&signal_set);
 	pthread_sigmask(SIG_BLOCK, &signal_set, &old_set);
 
 	pid = fork();
Index: main/asterisk.c
===================================================================
--- main/asterisk.c	(revision 428631)
+++ main/asterisk.c	(working copy)
@@ -4366,12 +4366,14 @@
 	}
 
 	ast_makesocket();
-	sigemptyset(&sigs);
-	sigaddset(&sigs, SIGHUP);
-	sigaddset(&sigs, SIGTERM);
-	sigaddset(&sigs, SIGINT);
-	sigaddset(&sigs, SIGPIPE);
-	sigaddset(&sigs, SIGWINCH);
+	/* GCC 4.9 gives a bogus "right-hand operand of comma expression has
+	 * no effect" warning */
+	(void) sigemptyset(&sigs);
+	(void) sigaddset(&sigs, SIGHUP);
+	(void) sigaddset(&sigs, SIGTERM);
+	(void) sigaddset(&sigs, SIGINT);
+	(void) sigaddset(&sigs, SIGPIPE);
+	(void) sigaddset(&sigs, SIGWINCH);
 	pthread_sigmask(SIG_BLOCK, &sigs, NULL);
 	sigaction(SIGURG, &urg_handler, NULL);
 	signal(SIGINT, __quit_handler);
Index: main/bridge_channel.c
===================================================================
--- main/bridge_channel.c	(revision 428631)
+++ main/bridge_channel.c	(working copy)
@@ -35,7 +35,6 @@
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
 #include <signal.h>
-#include <semaphore.h>
 
 #include "asterisk/heap.h"
 #include "asterisk/astobj2.h"
@@ -56,6 +55,7 @@
 #include "asterisk/parking.h"
 #include "asterisk/causes.h"
 #include "asterisk/test.h"
+#include "asterisk/sem.h"
 
 /*!
  * \brief Used to queue an action frame onto a bridge channel and write an action frame into a bridge.
@@ -101,7 +101,7 @@
 	/*! Unique ID of this synchronization object. Corresponds with ID in synchronous frame payload */
 	unsigned int id;
 	/*! Semaphore used for synchronization */
-	sem_t sem;
+	struct ast_sem sem;
 	/*! Pointer to next entry in the list */
 	AST_LIST_ENTRY(bridge_sync) list;
 };
@@ -124,7 +124,7 @@
 {
 	memset(sync_struct, 0, sizeof(*sync_struct));
 	sync_struct->id = id;
-	sem_init(&sync_struct->sem, 0, 0);
+	ast_sem_init(&sync_struct->sem, 0, 0);
 
 	AST_RWLIST_WRLOCK(&sync_structs);
 	AST_RWLIST_INSERT_TAIL(&sync_structs, sync_struct, list);
@@ -157,7 +157,7 @@
 	AST_LIST_TRAVERSE_SAFE_END;
 	AST_RWLIST_UNLOCK(&sync_structs);
 
-	sem_destroy(&sync_struct->sem);
+	ast_sem_destroy(&sync_struct->sem);
 }
 
 /*!
@@ -189,7 +189,7 @@
 		.tv_nsec = timeout_val.tv_usec * 1000,
 	};
 
-	sem_timedwait(&sync_struct->sem, &timeout_spec);
+	ast_sem_timedwait(&sync_struct->sem, &timeout_spec);
 }
 
 /*!
@@ -204,7 +204,7 @@
  */
 static void bridge_sync_signal(struct bridge_sync *sync_struct)
 {
-	sem_post(&sync_struct->sem);
+	ast_sem_post(&sync_struct->sem);
 }
 
 void ast_bridge_channel_lock_bridge(struct ast_bridge_channel *bridge_channel)
Index: main/rtp_engine.c
===================================================================
--- main/rtp_engine.c	(revision 428631)
+++ main/rtp_engine.c	(working copy)
@@ -1931,8 +1931,8 @@
 	if (payload->report->type == AST_RTP_RTCP_SR) {
 		char sec[32];
 		char usec[32];
-		snprintf(sec, sizeof(sec), "%lu", payload->report->sender_information.ntp_timestamp.tv_sec);
-		snprintf(usec, sizeof(usec), "%lu", payload->report->sender_information.ntp_timestamp.tv_usec);
+		snprintf(sec, sizeof(sec), "%ld", payload->report->sender_information.ntp_timestamp.tv_sec);
+		snprintf(usec, sizeof(usec), "%ld", (long)payload->report->sender_information.ntp_timestamp.tv_usec);
 		json_rtcp_sender_info = ast_json_pack("{s: s, s: s, s: i, s: i, s: i}",
 				"ntp_timestamp_sec", sec,
 				"ntp_timestamp_usec", usec,
Index: main/sem.c
===================================================================
--- main/sem.c	(revision 428631)
+++ main/sem.c	(working copy)
@@ -85,6 +85,7 @@
 
 int ast_sem_wait(struct ast_sem *sem)
 {
+	int res;
 	SCOPED_MUTEX(lock, &sem->mutex);
 
 	ast_assert(sem->count >= 0);
@@ -92,7 +93,12 @@
 	/* Wait for a non-zero count */
 	++sem->waiters;
 	while (sem->count == 0) {
-		ast_cond_wait(&sem->cond, &sem->mutex);
+		res = ast_cond_wait(&sem->cond, &sem->mutex);
+		/* Give up on error */
+		if (res != 0) {
+			--sem->waiters;
+			return res;
+		}
 	}
 	--sem->waiters;
 
@@ -102,6 +108,31 @@
 	return 0;
 }
 
+int ast_sem_timedwait(struct ast_sem *sem, const struct timespec *abs_timeout)
+{
+	int res;
+	SCOPED_MUTEX(lock, &sem->mutex);
+
+	ast_assert(sem->count >= 0);
+
+	/* Wait for a non-zero count */
+	++sem->waiters;
+	while (sem->count == 0) {
+		res = ast_cond_timedwait(&sem->cond, &sem->mutex, abs_timeout);
+		/* Give up on error */
+		if (res != 0) {
+			--sem->waiters;
+			return res;
+		}
+	}
+	--sem->waiters;
+
+	/* Take it! */
+	--sem->count;
+
+	return 0;
+}
+
 int ast_sem_getvalue(struct ast_sem *sem, int *sval)
 {
 	SCOPED_MUTEX(lock, &sem->mutex);
